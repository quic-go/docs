{"/docs/":{"data":{"":"","http3#HTTP/3":"quic-go also has support for HTTP/3 (RFC 9114), including QPACK (RFC 9204) and HTTP Datagrams (RFC 9297).\nWith this package, it is possible to run a Go server that serves HTTP/1.1, HTTP/2 and HTTP/3.","masque#MASQUE":"Support for Proxying UDP in HTTP (RFC 9298) will be added soon.","quic#QUIC":"quic-go is an optimized, production-ready implementation of the QUIC protocol (RFC 9000, RFC 9001, RFC 9002), including several QUIC extensions.","webtransport#WebTransport":"Support for WebTransport over HTTP/3 (draft-ietf-webtrans-http3) is implemented in webtransport-go."},"title":"The quic-go Protocol Suite"},"/docs/connect-udp/":{"data":{"":"CONNECT-UDP (RFC 9298) enables the proxying of UDP packets over HTTP/3. It is implemented in masque-go.","protocol-overview#Protocol Overview":"A client establishes an HTTP/3 connection to a proxy. It requests the proxying of UDP packets to a remote server by sending an Extended CONNECT (RFC 9220) HTTP request. If the proxy accepts the proxying request, it opens a UDP socket to the target and forwards UDP packets between the client and the target. Between the client and the proxy, UDP datagrams are sent on the QUIC connection using HTTP Datagrams (RFC 9279).\nsequenceDiagram participant Client participant Proxy participant Server as Target Server Client-\u003e\u003eProxy: Extended CONNECT Proxying Request Proxy--\u003e\u003eProxy: Open UDP Socket to Server loop UDP Proxying Client-\u003e\u003eProxy: UDP payload sent in HTTP Datagram Proxy-\u003e\u003eServer: UDP Packet Server--\u003e\u003eProxy: UDP Packet Proxy-\u003e\u003eClient: UDP payload sent in HTTP Datagram end"},"title":"Proxying UDP in HTTP"},"/docs/connect-udp/client/":{"data":{"":"","-future-work#üìù Future Work":" Logging / Tracing: #59 Proxying a UDP Listener: #64 ","setting-up-a-proxied-connection#Setting up a Proxied Connection":"A client needs to be configured with the same URI template as the proxy. For more information on URI templates, see URI Templates.\ntemplate := uritemplate.MustNew(\"https://example.org:4443/masque?h={target_host}\u0026p={target_port}\") Client.DialAddr can then be used establish proxied connections to servers by hostname. In this case, DNS resolution is handled by the proxy:\ncl := masque.Client{} // dial a target with a hostname conn, rsp, err := cl.DialAddr(ctx, template, \"quic-go.net:443\") Client.Dial can be used to establish proxied connections to servers by IP address:\nconn, rsp, err := cl.Dial(ctx, template,\u003c*net.UDPAddr\u003e) The net.PacketConn returned from these methods is only non-nil if the proxy accepted the proxying request. This is the case if the HTTP status code is in the 2xx range:\nconn, rsp, err := cl.DialAddr(ctx, template, \"quic-go.net:443\") // ... handle error ... if rsp.StatusCode \u003c 200 \u0026\u0026 rsp.StatusCode \u003e 299 { // proxying request rejected // The response status code and body might contain more information. return } // use conn to send and receive UDP datagrams to the target Multiple UDP flows can be proxied over the same QUIC connection to the proxy by calling DialAddr and / or Dial multiple times on the same Client."},"title":"Running a Client"},"/docs/connect-udp/proxy/":{"data":{"":"","-future-work#üìù Future Work":"To create a CONNECT-UDP proxy server, the following steps are necessary:\nSet up an HTTP/3 server that defines an http.Handler for the URI template. Decode the client‚Äôs request and create a socket to the target. Use the masque.Proxy to handle proxying UDP of the UDP packet flow. URI Templates HTTP clients are configured to use a CONNECT-UDP proxy with a URI Template (RFC 6570). This URI template encodes the target host and port number.\nFor example, for a proxy running on https://proxy.example.com, these are possible URI templates:\nhttps://proxy.example.org:4443/masque?h={target_host}\u0026p={target_port} https://proxy.example.org:4443/masque/{target_host}/{target_port} The target_host can either be a hostname or an IP address. In case a hostname is used, DNS resolution is handled by the proxy.\nWhen receiving a request at the specified HTTP handler, the server decodes the URI template and opens a UDP socket to the requested target.\nHandling Proxying Requests To run a CONNECT-UDP proxy on https://example.org:4443 with the URI template https://example.org:4443/masque?h={target_host}\u0026p={target_port}:\nt := uritemplate.MustNew(\"https://example.org:4443/masque?h={target_host}\u0026p={target_port}\") // ... error handling var proxy masque.Proxy http.Handle(\"/masque\", func(w http.ResponseWriter, r *http.Request) { // parse the UDP proxying request mreq, err := masque.ParseRequest(r, t) if err != nil { var perr *masque.RequestParseError if errors.As(err, \u0026perr) { w.WriteHeader(perr.HTTPStatus) return } w.WriteHeader(http.StatusBadRequest) return } // optional: whitelisting / blacklisting logic // start proxying UDP datagrams back and forth err = proxy.Proxy(w, mreq) // ... error handling } // set up HTTP/3 server on :4443 s := http3.Server{Addr: \":4443\"} s.ListenAndServeTLS(\u003ccertfile\u003e, \u003ckeyfile\u003e) masque.ParseRequest parses the Extended CONNECT request, and extracts the target host and port from the URI template. If parsing of the request fails, it returns a masque.RequestParseError. This struct contains a field ‚ÄòHTTPStatus‚Äô, allowing the application to reject invalid requests with the correct HTTP status code.\nThe masque.Request.Target contains the requested target encoded as {target_host}:{target_port}. Applications can implement custom logic to decide which proxying requests are permissible.\n‚ö†Ô∏è Applications may add custom header fields to the response header, but must not call WriteHeader on the http.ResponseWriter The header is sent when Proxy.Proxy is called. For more details on how to set up and configure an HTTP/3 server, see Serving HTTP/3.\nManaging UDP Sockets The proxy.Proxy function used above creates a new connected UDP socket on :0 to send UDP datagrams to the target.\nAn application that wishes a more fine-grained control over the socket can instead use Proxy.ProxyConnectedSocket:\nhttp.Handle(\"/masque\", func(w http.ResponseWriter, r *http.Request) { // parse the UDP proxying request mreq, err := masque.ParseRequest(r, t) // ... handle error, as above ... // custom logic to resolve and create a UDP socket addr, err := net.ResolveUDPAddr(\"udp\", mreq.Target) // ... handle error ... conn, err := net.DialUDP(\"udp\", addr) // ... handle error ... err = proxy.ProxyConnectedSocket(w, mreq, conn) // ... handle error ... } The net.UDPConn passed to ProxyConnectedSocket is closed by the proxy after proxying is done.\n‚ö†Ô∏è Note that it is currently not possible to use unconnected UDP sockets (issue #3). It is invalid to pass an unconnected socket to ProxyConnectedSocket. üìù Future Work Unconnected UDP sockets: #3 Use the Proxy-Status HTTP header (RFC 9209) to communicate failures: #2 Use GSO and GRO to speed up UDP packet processing: #31 and #32 Logging / Tracing: #59 Proxying a UDP Listener: #64 ","handling-proxying-requests#Handling Proxying Requests":"","managing-udp-sockets#Managing UDP Sockets":"","uri-templates#URI Templates":""},"title":"Running a Proxy"},"/docs/http3/":{"data":{"":"While HTTP/1.1 and HTTP/2 both run on top of TCP connections, HTTP/3 is the HTTP version that runs on top of QUIC.\nThe http3 package of quic-go implements HTTP/3 (RFC 9114), including QPACK (RFC 9204). It aims to provide feature parity with the standard library‚Äôs HTTP/1.1 and HTTP/2 implementation."},"title":"HTTP/3"},"/docs/http3/client/":{"data":{"":"","future-work#üìù Future Work":"This package provides a http.RoundTripper implementation that can be used on the http.Client:\ntr := \u0026http3.Transport{ TLSClientConfig: \u0026tls.Config{}, // set a TLS client config, if desired QUICConfig: \u0026quic.Config{}, // QUIC connection options } defer tr.Close() client := \u0026http.Client{ Transport: tr, } The http.Client can then be used to perform HTTP requests over HTTP/3.\nUsing a quic.Transport To use a custom quic.Transport, the function used to dial new QUIC connections can be configured:\ntr := quic.Transport{} h3tr := \u0026http3.Transport{ TLSClientConfig: \u0026tls.Config{}, // set a TLS client config, if desired QUICConfig: \u0026quic.Config{}, // QUIC connection options Dial: func(ctx context.Context, addr string, tlsConf *tls.Config, quicConf *quic.Config) (quic.EarlyConnection, error) { a, err := net.ResolveUDPAddr(\"udp\", addr) if err != nil { return nil, err } return tr.DialEarly(ctx, a, tlsConf, quicConf) }, } This gives the application more fine-grained control over the configuration of the quic.Transport.\nRunning Client and Server on the Same Socket Since QUIC demultiplexes packets based on their connection IDs, it is possible allows running a QUIC server and client on the same UDP socket. This also works when using HTTP/3: HTTP requests can be sent from the same socket that a server is listening on.\nTo achieve this using this package, first initialize a single quic.Transport, and pass a quic.EarlyListner obtained from that transport to http3.Server.ServeListener, and use the DialEarly function of the transport as the Dial function for the http3.Transport.\nUsing 0-RTT The use of 0-RTT was not anticipated by Go‚Äôs standard library, and Go doesn‚Äôt have 0-RTT support, neither in its crypto/tls nor in its net/http implementation (not even for TLS 1.3 on top of TCP). The http3 package therefore defines two new request methods: http3.MethodGet0RTT for GET requests and http3.MethodHead0RTT for HEAD requests.\n‚ö†Ô∏è Support for the ‚ÄúEarly-Data‚Äù header field, as well as the ‚ÄúToo Early‚Äù status code (425) defined in RFC 8470 is not yet implemented. See üìù Future Work. It is the application‚Äôs responsibility to make sure that it is actually safe to send a request in 0-RTT, as outlined in Security Properties of 0-RTT. Requests sent in 0-RTT can be replayed on a new connection by an on-path attacker, so 0-RTT should only be used for idempotent requests. RFC 8740 defines some guidance on how to use 0-RTT in HTTP.\ntr := \u0026http3.Transport{ TLSClientConfig: \u0026tls.Config{ ClientSessionCache: tls.NewLRUClientSessionCache(100), }, } req, err := http.NewRequest(http3.MethodGet0RTT, \"https://my-server/path\", nil) // ... handle error ... tr.RoundTrip(req) The code snippet shows all the knobs that need to be turned to send a request in 0-RTT data:\nTLS session resumption must be enabled by configuring a tls.ClientSessionCache on the tls.Config. The request method needs to be set to http3.MethodGet0RTT. üìù Future Work Support for zstd Content Encoding: #4100 qlog Support: #4124 Happy Eyeballs Support: #3755 Support for Extensible Priorities (RFC 9218): #3470 Use Early-Data header field for 0-RTT requests, retry on 425 response status: #4381 ","running-client-and-server-on-the-same-socket#Running Client and Server on the Same Socket":"","using-0-rtt#Using 0-RTT":"","using-a-quictransport#Using a \u003ccode\u003equic.Transport\u003c/code\u003e":""},"title":"Dialing HTTP/3"},"/docs/http3/datagrams/":{"data":{"":"RFC 9297 defines how QUIC datagrams (as defined in RFC 9221) can be used in HTTP.\nAll HTTP Datagrams are associated with an HTTP request. Datagrams can only be sent with an HTTP request methods that explicitly supports them. For example, the GET and POST methods can‚Äôt be used for HTTP Datagrams.","on-the-client-side#On the Client Side":"On the client side, the client needs to use an http3.ClientConn from the http3.Transport. It is not possible to use HTTP datagrams when using the Transport‚Äôs RoundTrip method.\nThe http3.ClientConn manages a single QUIC connection to a remote server.\nThe client is required to check that the server enabled HTTP datagrams support by checking the SETTINGS:\n// ... dial a quic.Connection to the target server // make sure to set the \"h3\" ALPN tr := \u0026http3.Transport{ EnableDatagrams: true, } conn := tr.NewClientConn(qconn) // wait for the server's SETTINGS select { case \u003c-conn.ReceivedSettings(): case \u003c-conn.Context().Done(): // connection closed return } settings := conn.Settings() if !settings.EnableDatagrams { // no datagram support return } Since an HTTP/3 server can send SETTINGS in 0.5-RTT data, the SETTINGS are usually available right after completion of the QUIC handshake (barring packet loss, or an unoptimized HTTP/3 server implementation).\nstr, err := rt.OpenRequestStream(ctx) // ... handle error ... // send the HTTP request err = str.SendRequestHeader(req) // ... handle error ... // It now takes (at least) 1 RTT until we receive the server's HTTP response. // We can start sending HTTP datagrams now. go func() { // send an HTTP datagram err := str.SendDatagram([]byte(\"foobar\")) // ... handle error ... // receive an HTTP datagram data, err := str.ReceiveDatagram(context.Background()) // ... handle error ... }() // read the server's HTTP response rsp, err := str.ReadResponse() // ... handle error ... The ClientCon splits the sending of the HTTP request and the receiving of the HTTP response into two separate API calls (compare that to the standard library‚Äôs RoundTrip function). The reason is that sending an HTTP request and receiving the HTTP response from the server takes (at least) one network roundtrip. RFC 9297 allows the sending of HTTP datagrams as soon as the request has been sent.","on-the-server-side#On the Server Side":"Since HTTP Datagram support is an HTTP/3 extension, it needs to be negotiated using the HTTP/3 SETTINGS before it can be used. Since SETTINGS are sent in a unidirectional stream, it is not guaranteed that the SETTINGS are available as soon as the QUIC handshake completes.\nFor example, if a client sends a request immediately after the handshake completes and the QUIC packet containing the SETTINGS is lost, the SETTINGS will not be available until a retransmission is received.\nTo use HTTP datagrams, the server is required to check that support is actually enabled.\nhttp.HandleFunc(\"/datagrams\", func(w http.ResponseWriter, r *http.Request) { conn := w.(http3.Hijacker).Connection() // wait for the client's SETTINGS select { case \u003c-conn.ReceivedSettings(): case \u003c-time.After(10 * time.Second): // didn't receive SETTINGS within 10 seconds w.WriteHeader(http.StatusBadRequest) return } // check that HTTP Datagram support is enabled settings := conn.Settings() if !settings.EnableDatagrams { w.WriteHeader(http.StatusBadRequest) return } // HTTP datagrams are available w.WriteHeader(http.StatusOK) // ... handle the request ... }) After HTTP datagram has been verified, it is possible to ‚Äútake over‚Äù the stream by type-asserting the http.ResponseWriter to an http3.HTTPStreamer and calling the HTTPStream method. The returned http3.Stream has two methods, SendDatagram and ReceiveDatagram, to send and receive datagrams, respectively.\nOnce HTTPStream has been called, the stream behaves akin to a QUIC Stream in terms of reads, writes and stream cancellations.\nWhen writing to the http.ResponseWriter, the HTTP/3 layer applies framing using HTTP/3 DATA frames. By taking over the streams we gain access to the underlying QUIC stream: data passed to Write is written to the stream directly, and Read reads from the stream directly. This is a requirement for the Capsule protocol defined in section 3 of RFC 9297.\nContinuing the code sample from above:\nhttp.HandleFunc(\"/datagrams\", func(w http.ResponseWriter, r *http.Request) { // ... check for HTTP datagram support, see above w.WriteHeader(http.StatusOK) str := w.(http3.HTTPStreamer).HTTPStream() // send an HTTP datagram err := str.SendDatagram([]byte(\"foobar\")) // ... handle error ... // receive an HTTP datagram data, err := str.ReceiveDatagram(context.Background()) // ... handle error ... // send data directly on the QUIC stream str.Write([]byte(\"message\")) str.Close() }) "},"title":"HTTP Datagrams"},"/docs/http3/qpack/":{"data":{"":"HTTP/3 utilizes QPACK (RFC 9204) for efficient HTTP header field compression. Our implementation, available at quic-go/qpack, provides a minimal implementation of the protocol.","-future-work#üìù Future Work":" Add support for the QPACK dynamic table: #2424 and qpack#33 QPACK Error Codes: #4406 ","implementation-status#Implementation Status":"While the current implementation is a fully interoperable implementation of the QPACK protocol, it only uses the static compression table. The dynamic table would allow for more effective compression of frequently transmitted header fields. This can be particularly beneficial in scenarios where headers have considerable redundancy or in high-throughput environments.\nIf you think that your application would benefit from higher compression efficiency, or if you‚Äôre interested in contributing improvements here, please let us know in #2424."},"title":"QPACK Header Field Compression"},"/docs/http3/server/":{"data":{"":"","-future-work#üìù Future Work":" Correctly deal with 0-RTT and HTTP/3 extensions: #3855 Support for Extensible Priorities (RFC 9218): #3470 Support for httptrace: #3342 ","0-rtt#0-RTT":"By default, the http3.Server enables 0-RTT support on the QUIC layer, thereby allowing clients to send requests using 0-RTT. When using a user-provided quic.Config, 0-RTT is only enabled when the Allow0RTT config flag is set.\nAn http.Handler can determine if a request was received before completion of the handshake by examining the tls.ConnectionState associated with the request.\nfunc(w http.ResponseWriter, r *http.Request) { wasPotentiallyReplayed := !r.TLS.HandshakeComplete } ‚ÑπÔ∏è As soon as the QUIC handshake completes, it is certain that any HTTP requests sent on the connection were not replayed, even if they were sent in 0-RTT data. ","advertising-http3-via-alt-svc#Advertising HTTP/3 via Alt-Svc":"","graceful-shutdown#Graceful Shutdown":"The http3.Server can be gracefully closed by calling the Shutdown. The server then stops accepting new connections. Existing connections are served until all active requests have completed.\nctx, cancel := context.WithTimeout(context.Background(), time.Minute) defer cancel() server.Shutdown(ctx) On the wire, graceful shutdown is signaled by sending a GOAWAY frame. This tells clients that the server will not accept any new requests. Clients are expected to finish processing existing requests and then close the QUIC connection.\n‚ÑπÔ∏è Client behavior for handling GOAWAY frames is currently not implemented in quic-go yet, see #153. Shutdown returns when all active requests have been served, or when the context is canceled. In that case, all remaining active QUIC connections are closed, which abruptly terminates the remaining requests.\n‚ö†Ô∏è As noted above, it is the caller‚Äôs responsibility to close QUIC connections passed to ServeQUICConn. Shutdown sends the GOAWAY frame on these connections, but it doesn‚Äôt close them. However, Shutdown blocks until these connections are closed. ","setting-up-a-http3server#Setting up a \u003ccode\u003ehttp3.Server\u003c/code\u003e":"","settings#Sending SETTINGS":"Using ListenAndServeQUIC The easiest way to start an HTTP/3 server is using\nmux := http.NewServeMux() // ... add HTTP handlers to mux ... // If mux is nil, the http.DefaultServeMux is used. http3.ListenAndServeQUIC(\"0.0.0.0:443\", \"/path/to/cert\", \"/path/to/key\", mux) Setting up a http3.Server For more configurability, set up an http3.Server explicitly:\nserver := http3.Server{ Handler: mux, Addr: \"0.0.0.0:443\", TLSConfig: http3.ConfigureTLSConfig(\u0026tls.Config{}), // use your tls.Config here QUICConfig: \u0026quic.Config{}, } err := server.ListenAndServe() http3.ConfigureTLSConfig takes a tls.Config and configures the GetConfigForClient such that the correct ALPN value for HTTP/3 is used.\nUsing a quic.Transport It is also possible to manually set up a quic.Transport, and then pass the listener to the server. This is useful when you want to set configuration options on the quic.Transport.\ntr := quic.Transport{Conn: conn} tlsConf := http3.ConfigureTLSConfig(\u0026tls.Config{}) // use your tls.Config here quicConf := \u0026quic.Config{} // QUIC connection options server := http3.Server{} ln, _ := tr.ListenEarly(tlsConf, quicConf) err := server.ServeListener(ln) Demultiplexing non-HTTP Protocols Alternatively, it is also possible to pass fully established QUIC connections to the HTTP/3 server. This is useful if the QUIC serves both HTTP/3 and other protocols. Connection can then be demultiplexed using the ALPN value (via NextProtos in the tls.Config).\ntr := quic.Transport{Conn: conn} tlsConf := http3.ConfigureTLSConfig(\u0026tls.Config{}) // use your tls.Config here quicConf := \u0026quic.Config{} // QUIC connection options server := http3.Server{} ln, _ := tr.ListenEarly(tlsConf, quicConf) for { c, _ := ln.Accept() switch c.ConnectionState().TLS.NegotiatedProtocol { case http3.NextProtoH3: go server.ServeQUICConn(c) // ... handle other protocols ... } } ‚ö†Ô∏è It is the caller‚Äôs responsibility to close QUIC connections passed to ServeQUICConn. Specifically, closing the server does not close the connection, and Close will block until all active requests have been served. Advertising HTTP/3 via Alt-Svc An HTTP/1.1 or HTTP/2 server can advertise that it is also offering the same resources on HTTP/3 using HTTP Alternative Services (Alt-Svc) header field. Section 3.1.1 of RFC 9114 specifies how to use this field to advertise support for HTTP/3.\nThis allows HTTP clients to discover support for HTTP/3. Clients may still continue using the existing HTTP connection on top of TCP, but might decide to connect via QUIC the next time.\nAn http.Handler can be wrapped to automatically add the Alt-Svc header field for non-HTTP/3 requests:\nserver := http3.Server{} var handler http.Handler = http.NewServeMux() // ... add HTTP handlers ... handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) { if r.ProtoMajor \u003c 3 { err := server.SetQUICHeaders(w.Header()) // ... handle error ... } handler.ServeHTTP(w, r) }) Reverse-Proxying If the HTTP/3 server is located behind an L4 reverse proxy, it might be listening on a different UDP port than the port that is exposed to the internet. To accomodate for this common scenario, the external port can be configured using the Port field of the http3.Server:\nserver := http3.Server{ Port: 443, // SetQUICHeaders will now generate the Alt-Svc header for port 443 } More complex scenarios can be handled by manually setting the Alt-Svc header field, or by overwriting the value added by SetQUICHeaders.\nSending SETTINGS As described in Section 7.2.4 of RFC 9114, both endpoints send each other a SETTINGS frame to convey configuration parameters. For example, SETTINGS are used to enable extensions, such as the datagram extension.\nTo allow the client to immediately make use of the settings, the SETTINGS frame is sent in 0.5-RTT data.","using-a-quictransport#Using a \u003ccode\u003equic.Transport\u003c/code\u003e":"","using-listenandservequic#Using \u003ccode\u003eListenAndServeQUIC\u003c/code\u003e":""},"title":"Serving HTTP/3"},"/docs/quic/":{"data":{"":"quic-go is a general-purpose implementation of the QUIC protocol (RFC 9000, RFC 9001, RFC 9002) in Go.\nIn addition to these base RFCs, it also implements the following RFCs:\nUnreliable Datagram Extension (RFC 9221) Datagram Packetization Layer Path MTU Discovery (DPLPMTUD, RFC 8899) QUIC Version 2 (RFC 9369) QUIC Event Logging using qlog (draft-ietf-quic-qlog-main-schema and draft-ietf-quic-qlog-quic-events) It is used by a wide variaty of users, see the README for a list of notable projects."},"title":"QUIC"},"/docs/quic/client/":{"data":{"":"","-future-work#üìù Future Work":" Mitigate Performance Impact of Large Certificates by sending two ClientHellos: #3775 Happy Eyeballs for DialAddr: #3772 ","0-rtt#0-RTT":"QUIC‚Äôs 0-RTT feature allows the client to send application data right away when resuming a connection to a server to which it connected before. Application data is sent before the handshake with the server completes.\nsequenceDiagram Client-\u003e\u003eServer: ClientHello activate Client rect rgb(220,220,220) Client--\u003e\u003eServer: 0-RTT Application data activate Server end deactivate Client Server-\u003e\u003e Client: ServerHello, Certificate, Finished activate Client rect rgb(220,220,220) Server--\u003e\u003eClient: 0.5-RTT Application data end deactivate Server Client-\u003e\u003eServer: (Client Certificates), Finished activate Server rect rgb(220,220,220) Client--\u003e\u003eServer: 1-RTT Application Data deactivate Client Server--\u003e\u003eClient: 1-RTT Application Data end deactivate ServerA client can use 0-RTT session resumption if a few conditions are met on the client side:\nIt needs to use TLS session resumption. There‚Äôs no way to use 0-RTT without a TLS session ticket. The server‚Äôs support for session resumption, indicated by the session ticket issued on the initial connection, must be present. The ALPN (configured using tls.Config.NextProtos) on the new connection must be the same. ‚ö†Ô∏è Due to the design of the TLS protocol, clients cannot directly request session tickets or unilaterally enable 0-RTT. These capabilities depend on the server‚Äôs configuration and support. To dial a 0-RTT connection, use DialEarly instead of Dial. quic-go performs the checks for the conditions listed above and dials a 0-RTT connection if they are met.\nctx, cancel := context.WithTimeout(context.Background(), 3*time.Second) defer cancel() tlsConf := \u0026tls.Config{ ClientSessionCache: tls.NewLRUClientSessionCache(100), } // 1. Use this tls.Config to establish the first connection to the server // and receive a session ticket ... // 2. Dial another connection to the same server conn, err := tr.DialEarly(ctx, \u003cserver address\u003e, tlsConf, \u003cquic.Config\u003e) // ... error handling // Check if 0-RTT is being used uses0RTT := conn.ConnectionState().Used0RTT // If 0-RTT was used, DialEarly returned immediately. // Open a stream and send some application data in 0-RTT ... str, err := conn.OpenStream() When performing a 0-RTT session resumption, the same flow control limits apply to the resumed session as to the original session, both in terms of the amount of data that can be sent on streams and the total number of streams that can be opened. quic-go achieves this by storing these values in the tls.SessionState associated with the session ticket.\n‚ö†Ô∏è Clients need to handle the possibility of servers rejecting 0-RTT handshakes, as outlined in Dealing with Rejections.\nThis adds some complexity to the use of 0-RTT, but it is imperative to correctly handle this case, as the server might reject 0-RTT for any reason.\nSecurity Properties of 0-RTT As described in Section 8 of RFC 8446, application data sent in 0-RTT (what TLS 1.3 calls ‚ÄúEarly Data‚Äù) has different security properties than application data sent after completion of the handshake. 0-RTT data is encrypted, and an observer won‚Äôt be able to decrypt it. However, since data is sent before the client has received any fresh key material from the server, an attacker can record the 0-RTT data and replay it to the server at a later point, or to a different server in a load-balanced server deployment.\nIn general it is only safe to perform idempotent actions in 0-RTT. It is the client‚Äôs responsibility to make sure that the data it sends is appropriate to send in 0-RTT. For many application protocols, this means limiting to the use of 0-RTT to certain kinds of data, and delaying the sending of other data until the handshake has completed.\nThis can easily be accomplished by blocking on the channel returned by HandshakeComplete.\nselect { case \u003c-conn.HandshakeComplete(): // Handshake complete. // All data sent from here on is protected against replay attacks. case \u003c-conn.Context().Done(): // Handshake failed. } Dealing with Rejections The server can reject a 0-RTT connection attempt for various reasons. When 0-RTT is rejected, this doesn‚Äôt lead to a failure of the QUIC handshake. Instead, the handshake proceeds as if it were a session resumption without 0-RTT.\nServers might reject 0-RTT due to:\nIncompatible changes in flow control parameters. Differences in the application protocol (negotiated using ALPN) from the initial connection. Server load, opting not to process 0-RTT packets at the time. As mentioned above, the client applies the flow control limits used on the initial connection to the resumed connection. For example, if the server was reconfigured after the initial connection, reducing the flow control limits, the client might unknowingly exceed these new limits. This scenario is a common reason for 0-RTT rejection.\nUpon rejecting 0-RTT, the server discards all 0-RTT packets sent by the client. This results in the invalidation of all opened streams and any data sent. quic-go does not automatically retransmit data sent in 0-RTT after completion of the handshake. It‚Äôs the application‚Äôs responsibility to detect this error and respond appropriately.\nThe quic.Connection returned by DialEarly behaves as if it had been closed: all calls to OpenStream, AcceptStream, as well as Read and Write calls on streams return a quic.Err0RTTRejected. However, the underlying QUIC connection remains open, it is only used as a signal to the application that all data sent so far was not processed by the server. To continue communication, the application can transition to using NextConnection:\nconn, err := tr.DialEarly(ctx, \u003cserver address\u003e, \u003ctls.Config\u003e, \u003cquic.Config\u003e) // ... error handling _, err :=conn.AcceptStream() if errors.Is(err, quic.Err0RTTRejected) { // The server rejected 0-RTT. None of the data sent so far was processed. newConn := conn.NextConnection() } ","tls-session-resumption#TLS Session Resumption":"Using a quic.Transport Since QUIC uses connection IDs to demultiplex connections, multiple outgoing connections can share a single UDP socket.\nctx, cancel := context.WithTimeout(context.Background(), 3*time.Second) // 3s handshake timeout defer cancel() conn, err := tr.Dial(ctx, \u003cserver address\u003e, \u003ctls.Config\u003e, \u003cquic.Config\u003e) // ... error handling Using the Convenience Functions As a shortcut, quic.Dial and quic.DialAddr can be used without explictly initializing a quic.Transport:\nctx, cancel := context.WithTimeout(context.Background(), 3*time.Second) // 3s handshake timeout defer cancel() conn, err := quic.Dial(ctx, conn, \u003cserver address\u003e, \u003ctls.Config\u003e, \u003cquic.Config\u003e) Just as we saw before when used a similar shortcut to run a server, it‚Äôs also not possible to reuse the same UDP socket for other outgoing connections, or to listen for incoming connections.\nTLS Session Resumption Just as a TLS client running on top of a TCP connection, a QUIC client can also use TLS session resumption. Session resumption allows the skipping of certain parts of the TLS handshake. For example, the server doesn‚Äôt need to send its certificate again.\nTo use session resumption, nothing needs to be done on the QUIC layer. It is enabled the same way as when using the standard library TLS over TCP, i.e. by settings the tls.Config.ClientSessionCache.","using-a-quictransport#Using a \u003ccode\u003equic.Transport\u003c/code\u003e":"","using-the-convenience-functions#Using the Convenience Functions":""},"title":"Running a QUIC Client"},"/docs/quic/congestion-control/":{"data":{"":"A congestion controller aims to regulate network traffic to prevent overloading the network, ensuring efficient data transmission while minimizing packet loss and delays. QUIC implementations have the flexibility to explore innovative congestion control algorithms. Currently, quic-go implements the congestion control algorithm specified in Section 7 of RFC 9002.","-future-work#üìù Future Work":" Implement L4S / Prague: #4002 Implement Careful Resumption of Congestion Control State: #4159 Pluggable Congestion Control: #776 "},"title":"Congestion Control"},"/docs/quic/connection-migration/":{"data":{"":"Whereas TCP identifies connection by their 4-tuple (i.e. the combination of the client‚Äôs and server‚Äôs IP address and port), QUIC uses connection IDs to demultiplex connections. This allows QUIC connections to migrate between paths.\nThis can be useful when a mobile phone moves away from a WiFi networks, and wishes to use the cellular connection instead. Connection migration is completely transparent to the application, as the entire connection, including all streams, is migrated to the new path.\n‚ö†Ô∏è Note that this is not equivalent to multipath support. Using connection migration as defined in RFC 9000, only a single path can be used to send application at a time.\nSee Multipath for the QUIC Multipath extension.","-future-work#üìù Future Work":"quic-go currently doesn‚Äôt implement connection migration at this point.\nTracking Issue: #234 API Proposal: #3990 "},"title":"Connection Migration"},"/docs/quic/connection/":{"data":{"":"","-future-work#üìù Future Work":" Better Configuration of Keep-Alives: #4382 ","closing#Closing a Connection":"","conn-context#Using the Connection Context":"","error-assertion#Inspecting the Error":"The quic.Connection is the central object to send and receive application data. Data is not sent directly on the connection, but either on streams, or (optionally) in so-called datagrams.\nUsing the Connection Context When a new QUIC connection is established, a number of callbacks might be called during the different stages of the QUIC handshake. Among those are:\nTLS configuration callbacks, e.g. tls.Config.GetConfigForClient, tls.Config.GetCertificate and tls.Config.GetClientCertificate QUIC connection tracer configuration (using quic.Config.Tracer), used for configuring qlog event logging, among others Applications can identify which QUIC connection these callbacks are called for by attaching values to the context using Transport.ConnContext (for incoming connections) and the context passed to Dial (for outgoing connections).\nFor example:\ntr := quic.Transport{ ConnContext: func(ctx context.Context) context.Context { // In practice, generate an identifier that's unique to this one connection, // for example by incrementing a counter. return context.WithValue(ctx, \"foo\", \"bar\") } } ln, err := tr.Listen(\u0026tls.Config{ GetConfigForClient: func(info *tls.ClientHelloInfo) *tls.Config { // this context has a key \"foo\" with value \"bar\" _ = info.Context() return \u003ctls.Config\u003e } }, nil) // ... error handling conn, err := ln.Accept() // ... error handling // this context has a key \"foo\" with value \"bar\" _ = conn.Context() The context passed to ConnContext is closed once the QUIC connection is closed, or if the handshake fails for any reason. This allows applications to clean up state that might they might have created in the ConnContext callback (e.g. by using context.AfterFunc).\nClosing a Connection At any point during the connection, a quic.Connection can be closed by calling CloseWithError:\nconn.CloseWithError(0x42, \"I don't want to talk to you anymore üôâ\") Error codes are defined by the application and can be any unsigned 62-bit value. The error message is a UTF-8 encoded human-readable reason. The error code allows the receiver to learn why the connection was closed, and the reason can be useful for debugging purposes. quic-go doesn‚Äôt provide a way to close a connection without providing an error code or an error message.\n‚ö†Ô∏è This instantly closes the connection. There‚Äôs no guarantee that any outstanding stream data or datagrams will be delivered. In particular, writing to a stream, closing the stream, and immediately closing the connection doesn‚Äôt guarantee that the peer has received all stream data.\nThe application is responsible for ensuring that all data has been delivered before closing the connection.\nClosing the connections makes all calls associated with this connection (accepting and opening streams, reading and writing on streams, sending and receiving datagrams, etc.) return immediately. On the receiver side, the error is surfaced as a quic.ApplicationError as soon as it is received.\n‚ö†Ô∏è If the connection is closed before the handshake completes, the error code might not be transmitted to the peer.\nInstead the error might be surfaced as a quic.TransportError with an APPLICATION_ERROR error code. This protects from application state being revealed unencrypted on the wire. See Section 10.2.3 of RFC 9000 for details.\nIdle Timeouts A QUIC connections can be closed automatically (i.e. without sending of any packets), if it is not used for a certain period of time, the so-called idle timeout. This is especially useful on mobile devices, where waking up the radio just to close a connection would be wasteful.\nDuring the handshake, both client and server advertise the longest time that they want to keep the connection alive when it is idle. Details are specified in Section 10.1 of RFC 9000. The idle timeout that applies to the connection is the minimum of the two values advertised by the client and by the server, respectively.\nThe idle timeout can be configured on a per-connection basis using the MaxIdleTimeout field on the quic.Config:\nquic.Config{ MaxIdleTimeout: 45 * time.Second, } Internally, every QUIC connection endpoint keeps track of the time when the connection was last used, and silently (without sending any packets) closes the connection if that period exceeds the negotiated idle timeout period.\nKeeping a Connection Alive Endpoints can prevent the idle timeout from closing a QUIC connection by regularly sending application data. However, an application can also request the QUIC stack to keep the connection alive. This is done by regularly sending a PING frame before the idle timeout expires. A PING frame is a mechanism in QUIC used purely to elicit an acknowledgment from the peer, ensuring the connection is considered active.\nKeep-Alives can be configured by setting the KeepAlivePeriod option on the quic.Config.\nquic.Config{ KeepAlivePeriod: 30 * time.Second, } This will cause a PING frame to be sent at least every KeepAlivePeriod. If the idle timeout negotiated between the two endpoints is shorter than the KeepAlivePeriod, PING frames will be sent more frequently.\n‚ö†Ô∏è Enabling Keep-Alives doesn‚Äôt mean that the connection can‚Äôt experience an idle timeout. For example, the remote node could have crashed, or the path could have become unusable for a number of reasons. Inspecting the Error In case the peer closes the QUIC connection, all calls to open streams, accept streams, as well as all methods on streams immediately return an error. Additionally, it is set as cancellation cause of the connection context. In most cases, applications won‚Äôt need to closely inspect the error returned.\nThe most common way to handle an error is by interface-asserting it to net.Error, and (for example) retry the last operation if it‚Äôs a temporary error.\nThe following example shows how to inspect an error in detail:\nvar ( statelessResetErr *quic.StatelessResetError handshakeTimeoutErr *quic.HandshakeTimeoutError idleTimeoutErr *quic.IdleTimeoutError appErr *quic.ApplicationError transportErr *quic.TransportError vnErr *quic.VersionNegotiationError ) switch { case errors.As(err, \u0026statelessResetErr): // stateless reset case errors.As(err, \u0026handshakeTimeoutErr): // connection timed out before completion of the handshake case errors.As(err, \u0026idleTimeoutErr): // idle timeout case errors.As(err, \u0026appErr): // application error remote := appErr.Remote // was the error triggered by the peer? errorCode := appErr.ErrorCode // application-defined error code errorMessage := appErr.ErrorMessage // application-defined error message case errors.As(err, \u0026transportErr): // transport error remote := transportErr.Remote // was the error triggered by the peer? errorCode := transportErr.ErrorCode // error code (RFC 9000, section 20.1) errorMessage := transportErr.ErrorMessage // error message case errors.As(err, \u0026vnErr): // version negotation error ourVersions := vnErr.Ours // locally supported QUIC versions theirVersions := vnErr.Theirs // QUIC versions support by the remote } quic.VersionNegotiationError: Happens during the handshake, if Version Negotiation fails, i.e. when there is no overlap between the client‚Äôs and the server‚Äôs supported QUIC versions. quic.HandshakeTimeoutError: Happens if the QUIC handshake doesn‚Äôt complete within the time specified in quic.Config.HandshakeTimeout. quic.IdleTimeoutError: Happens after completion of the handshake if the connection is idle for longer than the minimum of both peers idle timeouts. quic.StatelessResetError: Happens when a Stateless Reset is received. quic.TransportError: Happens if the QUIC protocol is violated. Unless the error code is APPLICATION_ERROR, this will not happen unless one of the QUIC stacks involved is misbehaving. Please open an issue if you encounter this error. quic.ApplicationError: Happens when the remote decides to close the connection, see above. ","idle-timeout#Idle Timeouts":""},"title":"QUIC Connection"},"/docs/quic/datagrams/":{"data":{"":"","-future-work#üìù Future Work":" general performance improvements in the DATAGRAM send and receive path introduce an API to query the current DATAGRAM size limit: #4259 notify the application when a DATAGRAM frame is acked / lost: #4273 ","sending-and-receiving-datagrams#Sending and Receiving Datagrams":"Datagrams are sent using the SendDatagram method on the quic.Connection:\nconn.SendDatagram([]byte(\"foobar\")) And received using ReceiveDatagram:\nmsg, err := conn.ReceiveDatagram(context.Background()) Note that this code path is currently not optimized. It works for datagrams that are sent occasionally, but it doesn‚Äôt achieve the same throughput as writing data on a stream. Please get in touch on issue #3766 if your use case relies on high datagram throughput, or if you‚Äôd like to help fix this issue.","the-unreliable-datagram-extension#The Unreliable Datagram Extension":"Unreliable datagrams are not part of QUIC (RFC 9000) itself, but a feature that is added by a QUIC extension (RFC 9221). As other extensions, it can be negotiated during the handshake. Support can be enabled by setting the quic.Config.EnableDatagram flag. Note that this doesn‚Äôt guarantee that the peer also supports datagrams. Whether or not the feature negotiation succeeded can be learned from the ConnectionState.SupportsDatagrams obtained from Connection.ConnectionState().\nQUIC DATAGRAMs are a new QUIC frame type sent in QUIC 1-RTT packets (i.e. after completion of the handshake). Therefore, they‚Äôre end-to-end encrypted and congestion-controlled. However, if a DATAGRAM frame is deemed lost by QUIC‚Äôs loss detection mechanism, they are not retransmitted."},"title":"Datagrams"},"/docs/quic/flowcontrol/":{"data":{"":"","-future-work#üìù Future Work":" queue stream-related frames with their respective stream: #4271 ","flow-control-for-data-sent-on-streams#Flow Control for Data sent on Streams":"","stream-num#Limiting the Number of Streams":"This page outlines the flow control algorithms used by QUIC. Flow control ensures that a sender doesn‚Äôt overwhelm the receiver with too much data (and too many new streams), if the receiver is not able to keep up with the sender‚Äôs rate. This is essential to control the resource consumption of a QUIC connection. On the other hand, misconfiguration of flow control limits often is the reason for suboptimal performance (see the BDP section).\nFlow Control for Data sent on Streams Flow control for data sent on streams is described in Section 4.1 of RFC 9000. QUIC imposes two separate limits:\nA per-stream limit, defining the maximum amount of data that can be sent on any stream. A per-connection limit, specifying the total amount of data that can sent across all streams. The per-connection limit makes it possible to use relatively high per-stream limits, while avoiding to commit a large amount of memory. For example, a QUIC stack might configure a per-stream window of 5 MB and a per-connection limit of 10 MB. Even if the peer opens 100 streams at the same time, the maximum memory commitment is limit to 10 MB (and not 500 MB).\nLimiting the Memory Commitment A malicious peer could send all stream data up the flow control limit, except for the very first byte of the stream. In that case, the receiver isn‚Äôt able to consume any data, but will have to buffer the received data.\nThis attack scenario is hard to distinguish from normal packet loss, where the packet containing the missing bytes happened to be lost. The flow control limit places an upper bound on our memory commitment (plus some overhead for the tracking data structures used).\nRelationship to the Bandwidth Delay Product (BDP) The Bandwidth Delay Product (BDP), i.e. the product of the connection‚Äôs RTT and the available bandwidth, is related to how much data can be in flight at any given time: If the receiver immediately acknowledges received data, it takes 1 RTT for the acknowledgment to arrive at the sender.\nFor example, on a connection with an available bandwidth of 1 Gbit/s and an RTT of 50ms, the BDP would be 6.25 MB.\nIf the receiver‚Äôs flow control window is smaller than the BDP, the receiver won‚Äôt be able to send any more data before receiving additional flow control credit, making it impossible to fully utilize the available bandwidth. quic-go therefore\nConfiguring Limits Flow control limits are configured on a per-connection basis using the quic.Config.\nquic.Config{ InitialStreamReceiveWindow: 1\u003c\u003c20, // 1 MB MaxStreamReceiveWindow: 6\u003c\u003c20, // 6 MB InitialConnectionReceiveWindow: 2\u003c\u003c20, // 2 MB MaxConnectionReceiveWindow: 12\u003c\u003c20, // 12 MB } The initial limits (InitialStreamReceiveWindow and InitialConnectionReceiveWindow) are advertised to the peer during the QUIC handshake, and apply to every new stream opened by the peer. The protocol doesn‚Äôt provide a way to change these limits after completion of the handshake.\nThe maximum limits (MaxStreamReceiveWindow and MaxConnectionReceiveWindow) are the maximum sizes that the auto-tuning algorithm increases the limits to for a well-connected peer that is making of these limits.\nThe QUIC protocol allows specifying different limits for unidirectional, incoming bidirectional and outgoing bidirectional streams, quic-go currently doesn‚Äôt expose configuration flags for that. The configuration flags provided apply to both streams types.\n‚ö†Ô∏è While this API allows setting the connection limit to a value lower than the stream limit, there are no situation where this would makes sense. Auto-Tuning of the Receive Window When a stream ‚Äì or the connection in total, in case the data is distributed across multiple streams ‚Äì consumes the entire flow control (or close to that value) over any RTT, this is a sign that the flow control window might too small to allow full utilization of the available BDP.\nIn that case, the auto-tuning logic doubles the receive window. The flow control window is doubled until either the peer doesn‚Äôt utilize the entire window within one RTT, or until the configured maximum value is reached.\nThis means that a suitable stream window size is usually reached within just a few network roundtrips.\nLimiting the Number of Streams A QUIC endpoint also imposes limits on the number of streams that the peer is allowed to open. The mechanism is described in Section 4.6 of RFC 9000.\nquic.Config{ MaxIncomingStreams: 100, // bidirectional streams MaxIncomingUniStreams: 100, // unidirectional streams } The QUIC protocol allows adjusting this number during the lifetime of the connection, similar to how it is possible to adjust the receive window. Currently, quic-go doesn‚Äôt expose an API for that.\nThese configuration flags determine the number of concurrent streams and not the total number of streams over the lifetime of a QUIC connection. Once a stream is closed and / or reset (in both directions, in the case of bidirectional streams), and all frames have been delivered to the peer, the peer is allowed to open a new stream.\n‚ö†Ô∏è The MaxIncomingStreams and MaxIncomingUniStreams configuration flags only impose a limit on how many streams the peer can open. They do not limit how many streams the endpoint itself can open. "},"title":"Flow Control"},"/docs/quic/metrics/":{"data":{"":"quic-go can expose metrics via Prometheus, providing a comprehensive overview of its operation. By leveraging the Tracer and ConnectionTracer interfaces, quic-go captures various events. These are the same interfaces used for qlog event logging.","-future-work#üìù Future Work":" Define more metrics: #4554 ","enabling-metrics-collection#Enabling Metrics Collection":"In your application, expose a Grafana endpoint on http://localhost:5001/prometheus:\nimport \"github.com/prometheus/client_golang/prometheus/promhttp\" go func() { http.Handle(\"/prometheus\", promhttp.Handler()) log.Fatal(http.ListenAndServe(\"localhost:5001\", nil)) }() Event that don‚Äôt belong to any QUIC connection, such as the sending of Version Negotiation packets, are captured on the Transport.Tracer:\nquic.Transport{ Tracer: metrics.NewTracer(), } Events belonging to a QUIC connection, such as the reason a connection was closed, are captured on the ConnectionTracer returned from Config.Tracer.\nquic.Config{ Tracer: metrics.DefaultConnectionTracer, } "},"title":"Prometheus Metrics"},"/docs/quic/multipath/":{"data":{"":"Multipath QUIC is a QUIC extension currently under development in the IETF QUIC working group. It allows the simultaneous use of multiple path for transferring application data.\nThe implementation status in quic-go is tracked in #3343."},"title":"Multipath"},"/docs/quic/optimizations/":{"data":{"":"","gso#Generic Segmentation Offload (GSO)":"Generic Segmentation Offload (GSO) net.UDPConn.WriteMsgUDP sends a single UDP packet. Under the hood, the standard library uses the sendmsg syscall. In principle, this is all we need to make QUIC work. However, for high-throughput transfers, the cost of these syscalls adds up.\nGeneric Segmentation Offload (GSO) allows applications to pass a large (up to 64 kB) buffer to the kernel, and have the kernel chop this buffer up into smaller pieces. This comes with a few requirements: all packets are sent to the same receiver address, and all packets except the last one need to have exactly the same size. quic-go handles all this complexity, and is able to optimize the creation of new packets by creating them in GSO-sized batched.\nGSO is currently only available on Linux for kernel versions from 4.18. On certain systems, GSO might still fail, which is why quic-go comes with GSO detection logic, and falls back to the non-GSO send path if GSO doesn‚Äôt properly work.\nThere is no config flag to disable GSO support, and it is not expected that users would ever want to disable GSO support. If you run into any GSO-related problem, please open an issue. It is however possible to globally disable GSO by setting the QUIC_GO_DISABLE_GSO environment variable to true.\nüìù Future Work GSO on Windows: #4325 amortize header protection cost by batching: #4371 ","path-mtu-discovery-dplpmtud#Path MTU Discovery (DPLPMTUD)":"RFC 9000 requires any QUIC path to support MTUs of at least 1200 bytes, but many paths on the internet support larger MTUs, some up to 1500 bytes. On some path, even larger MTUs are possible.\nDatagram Packetization Layer Path MTU Discovery (DPLPMTUD) allows a QUIC endpoint to determine the MTU available on a given path, and therefore increase the size of QUIC packets it sends. This is advantageus since there is a per-packet overhead: QUIC packet encryption, QUIC header protection, framing overhead, etc.\nDPLPMTUD is enabled by default. If desired, it can be disabled on a per-connection basis using the quic.Config:\nquic.Config{ DisablePathMTUDiscovery: false, } DPLPMTUD works by occasionally sending larger ‚Äúprobe packets‚Äù. If these packets are received and acknowledged, this confirms that the network path is capable of handling higher MTUs, and allows quic-go to increase the size of packets sent out. In terms of bandwidth consumption, DPLPMTUD is exceedingly cheap: over the lifetime of a connection, less than 10 probe packets are sent.\nüìù Future Work Handle decreasing MTUs: #3955 Make the maximum packet size configurable: #3385 ","udp-buffer-sizes#UDP Buffer Sizes":"Experiments have shown that QUIC transfers on high-bandwidth connections can be limited by the size of the UDP receive and send buffer. The receive buffer holds packets that have been received by the kernel, but not yet read by the application (quic-go in this case). The send buffer holds packets that have been sent by quic-go, but not sent out by the kernel. In both cases, once these buffers fill up, the kernel will drop any new incoming packet.\nTherefore, quic-go tries to increase the buffer size. The way to do this is OS-specific, and we currently have an implementation for Linux, Windows and macOS. However, an application is only allowed to do increase the buffer size up to a maximum value set in the kernel. Unfortunately, on Linux this value is rather small, too small for high-bandwidth QUIC transfers.\nnon-BSD It is recommended to increase the maximum buffer size by running:\nsysctl -w net.core.rmem_max=7340032 sysctl -w net.core.wmem_max=7340032 This command would increase the maximum send and the receive buffer size to roughly 7 MB. Note that these settings are not persisted across reboots.\nBSD Taken from: https://medium.com/@CameronSparr/increase-os-udp-buffers-to-improve-performance-51d167bb1360\nOn BSD/Darwin systems you need to add about a 15% padding to the kernel limit socket buffer. Meaning if you want a 25MB buffer (8388608 bytes) you need to set the kernel limit to 26214400*1.15 = 30146560.\nTo update the value immediately to 7 MB, type the following commands as root:\nsysctl -w kern.ipc.maxsockbuf=8441037 Add the following lines to the /etc/sysctl.conf file to keep this setting across reboots:\nkern.ipc.maxsockbuf=8441037 üìù Open Questions Setting UDP buffer sizes when using Docker: #3801 Setting UDP buffer sizes on OpenBSD: #3476 "},"title":"Optimizations"},"/docs/quic/qlog/":{"data":{"":"quic-go logs a wide range of events defined in draft-ietf-quic-qlog-quic-events, providing comprehensive insights in the internals of a QUIC connection. quic-go uses the streaming log format using JSON Text Sequences (JSON-SEQ), as defined in draft-ietf-quic-qlog-main-schema.\nqlog files can be processed by a number of 3rd-party tools. qvis has proven very useful for debugging all kinds of QUIC connection failures.","-future-work#üìù Future Work":" qlog support for HTTP/3: #4124 move to a different JSON serializer: #3373 ","events-associated-with-a-connection#Events associated with a Connection":"qlog can be activated by setting the Tracer callback on the Config. It is called as soon as quic-go decides to start the QUIC handshake for a new connection. qlog.DefaultConnectionTracer provides a connection tracer implementation which writes qlog files to a directory specified by the QLOGDIR environment variable, if set. The default qlog tracer can be used like this:\nquic.Config{ Tracer: qlog.DefaultConnectionTracer, } For more sophisticated use cases, applications can implement the callback:\nquic.Config{ Tracer: func( ctx context.Context, p logging.Perspective, connID quic.ConnectionID, ) *logging.ConnectionTracer { // application-defined logic } } The context.Context passed to this callback is never closed, and is derived from the context returned from quic.Config.ConnContext.\nIt is valid to return nil for the *logging.ConnectionTracer from this callback. In this case, qlogging will be disabled for this connection.","events-not-associated-with-a-connection#Events not associated with a Connection":"When listening for QUIC packets on a UDP socket, there are a couple of events that can happen before an incoming packet can be associated with a QUIC connection. For example, the QUIC packet header might be invalid, forcing us to drop the packet. Or the server might be overloaded and reject a new connection attempt.\nqlogging for these events can be enabled by configuring a Tracer on the Transport:\nf, err := os.Create(\"events.sqlog\") // ... error handling quic.Transport{ Tracer: qlog.NewTracer(f), } "},"title":"Event Logging using qlog"},"/docs/quic/server/":{"data":{"":"","-future-work#üìù Future Work":" Call GetConfigForClient after processing the ClientHello: #3862 Save the RTT measurement in the resumption token (not the session ticket): #4158 ","0-rtt#0-RTT":"From the server‚Äôs perspective, accepting 0-RTT connection looks very similar to accepting a 0.5-RTT connection. The main difference is that with 0-RTT, the client is able to open streams right away, which can be accepted using AcceptStream.\nsequenceDiagram Client-\u003e\u003eServer: ClientHello activate Client rect rgb(220,220,220) Client--\u003e\u003eServer: 0-RTT Application data activate Server end deactivate Client Server-\u003e\u003e Client: ServerHello, Certificate, Finished activate Client rect rgb(220,220,220) Server--\u003e\u003eClient: 0.5-RTT Application data end deactivate Server Client-\u003e\u003eServer: (Client Certificates), Finished activate Server rect rgb(220,220,220) Client--\u003e\u003eServer: 1-RTT Application Data deactivate Client Server--\u003e\u003eClient: 1-RTT Application Data end deactivate ServerTo allow clients to use 0-RTT resumption, the Allow0RTT flag needs to be set on the quic.Config.\nquicConf := \u0026quic.Config{Allow0RTT: true} ln, err := tr.ListenEarly(tlsConf, quicConf) // ... error handling conn, err := ln.Accept() // ... error handling go func() { // It is now possible to accept the streams which the client opened in 0-RTT. str, err := conn.AcceptStream() // ... error handling // Optionally, wait for the handshake to complete select { case \u003c-conn.HandshakeComplete(): // handshake completed case \u003c-conn.Context().Done(): // connection closed before handshake completion, e.g. due to handshake failure } }() It is possible to inspect the quic.ConnectionState to find out if a connection used 0-RTT resumption:\nused0RTT := conn.ConnectionState().Used0RTT ","05-rtt#0.5-RTT":"Using a quic.Transport The central entry point is the quic.Transport. A Transport manages all QUIC connections running on a single UDP socket. Since QUIC uses Connection IDs, it can demultiplex a listener (accepting incoming connections) and an arbitrary number of outgoing QUIC connections on the same UDP socket.\nudpConn, err := net.ListenUDP(\"udp4\", \u0026net.UDPAddr{Port: 1234}) // ... error handling tr := quic.Transport{ Conn: udpConn, } ln, err := tr.Listen(tlsConf, quicConf) // ... error handling for { conn, err := ln.Accept() // ... error handling // handle the connection, usually in a new Go routine } The listener ln can now be used to accept incoming QUIC connections by (repeatedly) calling the Accept method (see below for more information on the quic.Connection).\nThis listener can be closed independently from the underlying transport. Connections that are already established and accepted won‚Äôt be affected, but clients won‚Äôt be able to establish new connections.\nUsing the Convenience Functions As a shortcut, quic.Listen and quic.ListenAddr can be used without explicitly initializing a quic.Transport:\nln, err := quic.Listen(udpConn, tlsConf, quicConf) When using the shortcut, it‚Äôs not possible to reuse the same UDP socket for outgoing connections.\n‚ö†Ô∏è While closing the listener associated with a Transport doesn‚Äôt close QUIC connections accepted from this listener, closing a listener created using these shortcuts causes all accepted connections to be immediately terminated. Certificate Size Considerations During the initial phase of the QUIC handshake, before validating the client‚Äôs address, server response size is restricted to thrice the bytes received from the client, as outlined in RFC 9000, Section 8. This limitation helps prevent the use of QUIC servers in DDoS attack amplifications by ensuring a server cannot send an excessively large response to a potentially spoofed packet.\nGiven that the initial client packet is typically 1200 bytes, the server‚Äôs response is capped at 3600 bytes. This cap includes the server‚Äôs TLS certificate in its first response, and an oversized certificate can extend the handshake by an additional RTT. As large certificates are commonplace, optimizing the certificate chain‚Äôs size is advisable to avoid handshake delays, supported by insights from Fastly‚Äôs research.\n0.5-RTT The following diagram shows a (simplified) sequence diagram of the TLS handshake messages exchanged during the QUIC handshake, and at which place handshake data can be sent by both endpoints.\nsequenceDiagram Client-\u003e\u003eServer: ClientHello activate Server Server-\u003e\u003e Client: ServerHello, Certificate, Finished activate Client rect rgb(220,220,220) Server--\u003e\u003eClient: 0.5-RTT Application data end deactivate Server Client-\u003e\u003eServer: (Client Certificates), Finished activate Server rect rgb(220,220,220) Client--\u003e\u003eServer: 1-RTT Application Data deactivate Client Server--\u003e\u003eClient: 1-RTT Application Data end deactivate ServerThe server can send application data in its first flight, right after it has sent the TLS ServerHello and the Certificate. Since this happens right after receiving the ClientHello (which takes half a network roundtrip time after the client sent it), this is called 0.5-RTT data.\n‚ö†Ô∏è 0.5-RTT data is encrypted with the same keys that all data sent later is sent with. However, at this point in the handshake, the server has not yet received the client‚Äôs TLS certificate (if TLS client authentication is used). It‚Äôs important for implementations to avoid sending sensitive data to unauthenticated clients. A connection can be accepted at this early stage by using ListenEarly instead of Listen:\nln, err := tr.ListenEarly(tlsConf, quicConf) // ... error handling conn, err := ln.Accept() // ... error handling go func() { // It is now possible to open streams and send data in 0.5-RTT data str, err := conn.OpenStream() // ... error handling // Optionally, wait for the handshake to complete select { case \u003c-conn.HandshakeComplete(): // handshake completed case \u003c-conn.Context().Done(): // connection closed before handshake completion, e.g. due to handshake failure } }() As soon as the connection is accepted, it can open streams and send application data. If datagram support is negotiated, datagrams can be sent as well.\nAt any point, the application can wait for completion of the handshake by blocking on the channel returned by Connection.HandshakeComplete().","cert-size#Certificate Size Considerations":"","using-a-quictransport#Using a \u003ccode\u003equic.Transport\u003c/code\u003e":"","using-the-convenience-functions#Using the Convenience Functions":""},"title":"Running a QUIC Server"},"/docs/quic/streams/":{"data":{"":"","-future-work#üìù Future Work":" Stream Priorities: #437 QUIC Reliable Stream Reset extension: #4139 ","accepting-streams#Accepting Streams":"","opening-streams#Opening Streams":"","states#Stream States":"QUIC is a stream-multiplexed transport. A quic.Connection fundamentally differs from the net.Conn and the net.PacketConn interface defined in the standard library.\nData is sent and received on (unidirectional and bidirectional) streams, not on the connection itself. The stream state machine is described in detail in Section 3 of RFC 9000.\nIn addition to QUIC streams, application data can also sent in so-called QUIC datagram frames (see datagrams), if implementations can negotiate support for it.\nStream Types QUIC supports both unidirectional and bidirectional streams. A unidirectional stream is a stream that the initiator can only write to (quic.SendStream), and the receiver can only read from (quic.ReceiveStream). A bidirectional stream (quic.Stream) allows reading from and writing to for both sides.\nAccepting Streams On the receiver side, bidirectional streams are accepted using AcceptStream.\nfor { str, err := conn.AcceptStream(context.Background()) // ... error handling // handle the stream, usually in a new Go routine } AcceptUniStream accepts unidirectional streams:\nfor { str, err := conn.AcceptUniStream(context.Background()) // ... error handling // handle the stream, usually in a new Go routine } For most use cases, it makes sense to call these functions in a loop. These functions return an error when the underlying QUIC connection is closed.\nOpening Streams As described in Flow Control for Streams, endpoints impose limits on how many streams a peer may open. The receiver may grant additional streams at any point in the connection (typically when existing streams are closed), but it means that at the time we want to open a new stream, we might not be able to do so.\nOpenStream attempts to open a new bidirectional stream (quic.Stream), and it never blocks. If it‚Äôs currently not possible to open a new stream, it returns a net.Error timeout error:\nstr, err := conn.OpenStream() if nerr, ok := err.(net.Error); ok \u0026\u0026 nerr.Timeout() { // It's currently not possible to open another stream, // but it might be possible later, once the peer allowed us to do so. } To open a new unidirectional (send) stream (quic.SendStream), use OpenUniStream.\nOpenStreamSync opens a new bidirectional stream. If that‚Äôs not possible due to the peer‚Äôs stream limit, it blocks until the peer allows opening additional streams. In case that we‚Äôre allowed to open a new stream, this methods returns right away:\n// wait up to 5s to open a new bidirectional stream ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second) defer cancel() str, err := conn.OpenStreamSync(ctx) OpenUniStreamSync is the version of this function to open a new unidirectional (send) stream.\nBoth OpenStream and OpenStreamSync return an error when the underlying QUIC connection is closed.\nStream States quic-go exposes three different stream abstractions: A quic.SendStream and a quic.ReceiveStream, for the two directions of unidirectional streams, and a quic.Stream for bidirectional streams.\nSend Stream The quic.SendStream is a unidirectional stream opened by us. It implements the io.Writer interface. Invoking Close closes the stream, i.e. it sends a STREAM frame with the FIN bit set. On the receiver side, this will be surfaced as an io.EOF returned from the io.Reader once all data has been consumed.\nIf the application needs to abruptly stop sending data on a stream, it can do so by by calling CancelWrite with an application-defined error code (an unsigned 62-bit number). This call immediately halts data transmission; any pending data will not be retransmitted. On the receiver side, this is surfaced as a quic.StreamError containing that error code on stream.Read.\nOnce CancelWrite has been called to abort the stream, subsequent calls to Close are ineffective (no-op) - the stream‚Äôs abortive state cannot be reversed.\nIt is valid to call CancelWrite after Close. This immediately aborts transmission of stream data. Depending on the order in which the QUIC packets are received, the receiver will either surface this a normal or an abrupt stream termination to the application.\nReceive Stream The quic.ReceiveStream is a unidirectional stream opened by the peer. It implements the io.Reader interface. It returns an io.EOF once the peer closes the stream, i.e. once we receive a STREAM frame with the FIN bit set.\nIn case the application is no longer interest in receiving data from a quic.ReceiveStream, it can ask the sender to abort data transmission by calling CancelRead with an application-defined error code (an unsigned 62-bit number). On the receiver side, this surfaced as a quic.StreamError containing that error code on the io.Writer.\nBidirectional Stream Using QUIC streams is pretty straightforward. A bidirectional stream (quic.Stream) implements both these interfaces. Conceptually, a bidirectional stream can be thought of as the composition of two unidirectional streams in opposite directions.\n‚ö†Ô∏è Calling Close on a quic.Stream closes the send side of the stream. Note that for bidirectional streams, Close only closes the send side of the stream. It is still possible to read from the stream until the peer closes or resets the stream. CancelWrite only resets the send side of the stream. It is still possible to read from the stream until the peer closes or resets the stream. Similary, CancelRead only resets the receive side of the stream, and it is still possible to write to the stream.\nA bidirectional stream is only closed once both the read and the write side of the stream have been either closed or reset. Only then the peer is granted a new stream according to the maximum number of concurrent streams configured via quic.Config.MaxIncomingStreams.","stream-errors#Stream Errors":"When a stream is reset (i.e. when CancelRead or CancelWrite are used), applications can communicate an error code (a 62-bit unsigned integer value) to the peer. Subsequent calls to Read and Write may return an error that can be type-asserted as a quic.StreamError.\nQUIC itself does not interpret this value; instead, it is the responsibility of the application layer to assign specific meanings to different error codes.\nvar streamErr *quic.StreamError if errors.As(err, \u0026streamErr) { errorCode := streamErr.ErrorCode } In general, the error returned from Read and Write might not be a stream error at all: For example, the underlying QUIC connection might have been closed, which (implicitly) closes all streams as well. The error returned will then be one of the QUIC connection errors.\n‚ö†Ô∏è Be aware of a potential race condition: if the read side is canceled by the receiver using one error code while the write side is simultaneously canceled by the sender with a different error code, the resulting error codes observed by each peer may not match. ","stream-resets-and-partial-reliability#Stream Resets and Partial Reliability":"When the sender cancels sending on a stream (either unidirectional or bidirectional), it immediately stops transmitting STREAM frames for that stream. This includes retransmissions: If any stream data for this stream is lost, it will not be retransmitted.\nConversely, the receiver does not need to wait for all data to be delivered before indicating to the application that the stream has been reset.","stream-types#Stream Types":""},"title":"QUIC Streams"},"/docs/quic/transport/":{"data":{"":"","-future-work#üìù Future Work":" Compatible Version Negotiation RFC 9368: #3640 ","handling-non-quic-packets#Handling non-QUIC packets":"","initializing-a-transport#Initializing a Transport":"","stateless-reset#Stateless Resets":"","using-a-netpacketconn-thats-not-a-netudpconn#Using a \u003ccode\u003enet.PacketConn\u003c/code\u003e that\u0026rsquo;s not a \u003ccode\u003e*net.UDPConn\u003c/code\u003e":"","version-negotiation#Version Negotiation":"Initializing a Transport The central entrypoint into quic-go is the quic.Transport. It used both when running a QUIC server and when dialing QUIC connections.\nOther than TCP, which identifies connections by their 4-tuple (i.e. the combination of the client‚Äôs and server‚Äôs IP address and port), QUIC uses connection IDs to demultiplex connections. That means that an arbitrary number of QUIC connections can be run on the same UDP socket. It is even possible to run a server (accepting incoming connections) and clients (establishing outgoing connections) on the socket.\nThe following code creates a new quic.Transport that uses UDP port 6121 on all available interfaces.\naddr, err := net.ResolveUDPAddr(\"udp\", \"0.0.0.0:6121\") // ... error handling conn, err := net.ListenUDP(\"udp\", addr) // ... error handling tr := \u0026quic.Transport{ Conn: conn, } As a rule of thumb, it is only necessary to create separate quic.Transports when listening on multiple UDP ports, or when binding sockets to different network interfaces.\n‚ö†Ô∏è Keep in mind that to achieve decent transfer performance, you might need to increase the kernel‚Äôs UDP send and receive buffer size. Using a net.PacketConn that‚Äôs not a *net.UDPConn Transport.Conn is a net.PacketConn, allowing applications to use their own implementation of the net.PacketConn interface. With this, it is possible to do QUIC over transports other than UDP.\nHowever, if the net.PacketConn is indeed a wrapped *net.UDPConn, this could prevent quic-go from accessing kernel-based optimizations, leading to reduced transfer performance. For example, using ECN is only possible if the packets sent are actual UDP packets.\nApplications can test if their net.PacketConn implementation provides the required methods to enable these optimizations by using the OOBCapablePacketConn interface:\ntype myPacketConn struct{} var _ quic.OOBCapablePacketConn = \u0026myPacketConn{} Handling non-QUIC packets QUIC was designed to be demultiplexed with a number of common UDP-based protocols (see RFC 9443 for details). This is achieved by inspecting the first few bits of every incoming UDP packet.\ntr.ReadNonQUICPacket(ctx context.Context, b []byte) (int, net.Addr, error) Using the ReadNonQUICPacket method is preferable over implementation this inspection logic outside of quic-go, and passing a wrapped net.PacketConn to the Transport, as it allows quic-go to use a number of kernel-based optimization (e.g. GSO) that massively speed up QUIC transfers (see Optimizations).\nStateless Resets QUIC is designed to prevent off-path attackers from disrupting connections, unlike TCP where such attackers can close connections using RST packets.\nA problem arises when a QUIC endpoint is suddenly rebooted: It now receives QUIC packets for connections for which it doesn‚Äôt possess the TLS session keys anymore. For the peer, it would be beneficial if the connection could immediately be closed. Otherwise, it would have to wait for an idle timeout to occur.\nStateless resets, as outlined in Section 10.3 of RFC 9000, address this issue. Utilizing a static key and the connection ID from an incoming packet, a rebooted endpoint generates a 16-byte stateless reset token. This token is sent in a packet mimicking a standard QUIC packet. The peer, already aware of the stateless reset token linked to the connection ID, recognizes the stateless reset and can close the connection instantly.\nThe key used to calculate stateless reset tokens is configured on the quic.Transport:\n// load the key from disk, or derive it deterministically var statelessResetKey quic.StatelessResetKey quic.Transport{ StatelessResetKey: \u0026statelessResetKey, } Applications need to make sure that this key stays constant across reboots of the endpoint. One way to achieve this is to load it from a configuration file on disk. Alternatively, an application could also derive it from the TLS private key. Keeping this key confidential is essential to prevent off-path attackers from disrupting QUIC connections managed by the endpoint.\nVersion Negotiation QUIC is designed to accommodate the definition of new versions in the future. RFC 8999 describes the (minimal set of) properties of QUIC that must be fulfilled by all QUIC versions.\nBefore accepting a client‚Äôs QUIC connection attempt, the server checks if it supports the QUIC version offered by the client. If it doesn‚Äôt, it sends a Version Negotiation packet (Section 6 of RFC 8999), which lists all the versions supported by the server. The client can then pick a QUIC version that is supported by both nodes and initiate another connection attempt.\nQUIC Version 2 QUIC Version 2 was defined in RFC 9369. It introduces no new features compared to QUIC Version 1 (RFC 9000), but has a slightly different wire image. It aims to acclimate middleboxes to the fact that QUIC is not just a single version. This will (hopefully!) prevent ossification and make it possible to define new versions of QUIC later.\nConfiguring Versions quic-go currently supports both QUIC version 1 and 2. The supported versions can be configured using the Versions field on the quic.Config.\nquic.Config{ Versions: []quic.Version{quic.Version2, quic.Version1}, } For the client, the first version in the Versions slice is used when dialing a new connection. The remaining versions are only used if the server doesn‚Äôt support the first version and sends Version Negotiation packet. For the server, the order of the versions doesn‚Äôt have any meaning.\nBy default, quic-go supports both versions, but prefers version 1, as this is the most commonly deployed QUIC version at this time.\nDisabling Version Negotiation In certain deployments, clients know for a fact which QUIC versions a server supports. For example, in a p2p setting, a server might have advertised the supported QUIC versions in / with its address. In these cases, QUIC‚Äôs version negotiation doesn‚Äôt serve any purpose, but may expose the network to request forgery attacks as described in Section 21.5.5 of RFC 9000.\nThe sending of Version Negotiation packets can be disabled using the DisableVersionNegotiationPackets option:\nquic.Transport{ DisableVersionNegotiationPackets: true, } "},"title":"Transport"},"/docs/quic/wasm/":{"data":{"":"It is possible to compile an application using quic-go to WASM.\nSince the wasip1 API lacks support for network sockets, it‚Äôs necessary to create the UDP socket using the WASI socket extension.\nimport \"github.com/stealthrocket/net/wasip1\" conn, err := wasip1.ListenPacket(\"udp\", \"127.0.0.1:443\") // ... handle error ... ln, err := quic.Listen(conn, \u003ctls.Config\u003e, \u003cquic.Config\u003e) Note that wasip1.ListenPacket returns a net.PacketConn, not a *net.UDPConn, which means that quic-go won‚Äôt be able to use optimizations like GSO or ECN.\nThe code can then be compiled to wasm and run using wasirun:\nGOOS=wasip1 GOARCH=wasm go build -o myapp wasirun ./myapp It is currently not possible to use wasmedge, since it doesn‚Äôt allow sending of UDP datagrams.","-future-work#üìù Future Work":" Improve WASM support: #4524 ","limitations#Limitations":"It is not possible to use convenience functions like quic.ListenAddr and quic.DialAddr, since these functions create the UDP socket using the standard library net package."},"title":"WASM"},"/docs/webtransport/":{"data":{"":"WebTransport is a novel browser API that enables browsers to establish stream-multiplexed connections to a server. It is layered atop QUIC and HTTP/3, offering a fallback mechanism on HTTP/2 for scenarios where QUIC might be blocked.\nConceptually, WebTransport can be compared to WebSocket but utilizes QUIC instead of TCP, providing benefits such as stream multiplexing and support for datagrams‚Äîfeatures that enhance performance and efficiency for real-time communication. Despite these conceptual similarities, WebTransport and WebSocket differ significantly in their underlying protocols.","key-advantages-and-use-cases#Key Advantages and Use Cases":"WebTransport leverages QUIC to improve connection reliability and efficiency, especially beneficial for applications requiring rapid and stable communication, such as online gaming and live video streaming.\nA distinctive feature of WebTransport is serverCertificateHashes, which makes it possible to use certificates not signed by a Certificate Authority (CA).","specification-and-implementation-status#Specification and Implementation Status":"The WebTransport specification is still evolving, as the protocol is under active development in the IETF WebTransport Working Group.\nAs of now, both Chrome and Firefox support WebTransport over HTTP/3 in draft version 2. The HTTP/2 fallback is currently not implemented by either browser.\nwebtransport-go is the WebTransport implementation based on quic-go. It is compatible with both Chrome and Firefox at this point.\n‚ö†Ô∏è At some point in the future, browsers will update to a more recent IETF draft version (or the final RFC version).\nThere is no guarantee that browsers will update in a backwards-compatible way, or that webtransport-go will support multiple draft versions at the same time. Support for WebTransport therefore might break for a transition period, until both browsers and servers have been updated to the new version."},"title":"WebTransport"},"/docs/webtransport/client/":{"data":{"":"To dial a WebTransport session, initialize a webtransport.Dialer, and call the Dial function.\nvar d webtransport.Dialer // optionally, add custom headers var headers http.Header headers.Add(\"foo\", \"bar\") rsp, sess, err := d.Dial(ctx, \"https://example.com/webtransport\", headers) // err is only nil if rsp.StatusCode is a 2xx // Handle the session. Here goes the application logic. This initiates a new WebTransport session with the server by sending an Extended CONNECT request to the server. The server might reject this request, in which case the status code of the HTTP response will not be in the 2xx range.\nThe parameters for the underlying QUIC connection can be adjusted by setting the QUICConfig on the Dialer. Datagram support is required by WebTransport, and must be enabled on using quic.Config.EnableDatagrams.","-future-work#üìù Future Work":" Using the same QUIC connection for WebTransport and HTTP/3: #147 Allow Optimistic Opening of Streams: #136 Subprotocol Negotiation: #132 "},"title":"Running a Client"},"/docs/webtransport/server/":{"data":{"":"When a client establishes a new WebTransport session it:\nFirst establishes an HTTP/3 connection to the server. It sends an HTTP request (using the Extended CONNECT protocol) to the server, requesting to establish a WebTransport session. ","-future-work#üìù Future Work":" Subprotocol Negotiation: #132 Properly check Validity of the client‚Äôs SETTINGS: #106 ","accepting-a-webtransport-session#Accepting a WebTransport Session":"To start a WebTransport server, it is necessary to:\nSet up an HTTP/3 server. Set up an HTTP handler for the WebTransport Extended CONNECT request. The webtransport.Server wraps an http3.Server. For more details on how to set up and configure an HTTP/3 server, see Serving HTTP/3.\nAssume a server is running on example.com. This code starts an HTTP/3 server on (UDP) port 443. The server can handle regular HTTP/3 requests to https://example.com.\nTo accept the Extended CONNECT request, the application needs to define an HTTP handler. In this example, we want to accept WebTransport sessions at https://example.com/webtransport. It is possible to reject an upgrade request by sending a non-2xx status code. Inside the handler, calling webtransport.Server.Upgrade accepts the WebTransport session, and it returns a webtransport.Session.\ns := webtransport.Server{ H3: http3.Server{ Addr: \":443\", TLSConfig: \u0026tls.Config{}, // use your tls.Config here }, } // Create a new HTTP endpoint /webtransport. http.HandleFunc(\"/webtransport\", func(w http.ResponseWriter, r *http.Request) { sess, err := s.Upgrade(w, r) if err != nil { log.Printf(\"upgrading failed: %s\", err) w.WriteHeader(500) return } // Handle the session. Here goes the application logic. }) s.ListenAndServeTLS(\u003ccertFile\u003e, \u003ckeyFile\u003e) ","origin-validation#Origin Validation":"By default, the Upgrade function checks that the client‚Äôs request origin matches the host of the server. This prevents cross-site request forgery (CSRF) attacks, where an attacker could use a malicious web page to establish a WebTransport connection to a vulnerable application, with the application processing the connection as if it were part of the victim user‚Äôs session.\nApplications can change this default behavior by setting the webtransport.Server.CheckOrigin callback:\ns := webtransport.Server{ H3: http3.Server{Addr: \":443\"}, CheckOrigin: func(r *http.Request) bool { // custom validation logic }, } "},"title":"Running a Server"},"/docs/webtransport/session/":{"data":{"":"A WebTransport Session functions similarly to a QUIC Connection, enabling the opening and accepting of streams, as well as the sending and receiving of datagrams.\nThe API of webtransport.Session is almost identical to that of quic.Connection, with a few minor differences: For example, QUIC allows streams to be reset using a 62-bit error code, whereas WebTransport limits the error code range to 32 bits.","-future-work#üìù Future Work":" WebTransport Datagrams: #8 ","closing-a-webtransport-session#Closing a WebTransport Session":"The WebTransport session can be closed by calling the CloseWithError method:\nsess.CloseWithError(1234, \"please stop talking to me ü§ê\") Similar to closing a quic.Connection, this action causes all calls to AcceptStream and OpenStream, as well as stream Read and Write calls, to return immediately.\n‚ö†Ô∏è CloseWithError only closes the WebTransport session, but not the underlying QUIC connection. On the receiver side, this error will be surfaced as a webtransport.SessionError:\nvar sessErr *webtransport.SessionError if errors.As(err, \u0026sessErr) { errorCode := sessErr.ErrorCode errorMessage := sessErr.Message } Additionally, the underlying QUIC connection might close for various reasons, potentially triggering any of the errors detailed in the error assertion section."},"title":"Session"},"/docs/webtransport/streams/":{"data":{"":"A WebTransport stream functions similarly to a QUIC Stream. In particular, the stream state machines are exactly the same, as detailed in the QUIC Stream documentation. WebTransport supports both unidirectional and bidirectional streams.\nThe main difference between a QUIC stream and a WebTransport stream lies in the type of error codes used to reset the stream: QUIC allows error codes up to a 62-bit unsigned integer, while WebTransport error codes are limited to a 32-bit unsigned integer.","stream-errors#Stream Errors":"When a stream is reset (i.e. when CancelRead or CancelWrite are used), applications can communicate an error code to the peer. Subsequent calls to Read and Write may return an error that can be type-asserted as a quic.StreamError.\nWebTransport itself does not interpret this value; instead, it is the responsibility of the application layer to assign specific meanings to different error codes.\nBelow is an example of how to type-assert an error as a webtransport.StreamError:\nvar streamErr *webtransport.StreamError if errors.As(err, \u0026streamErr) { errorCode := streamErr.ErrorCode } "},"title":"Streams"}}